{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nimport global from 'global';\nimport { Channel } from '@storybook/channels';\nimport { logger } from '@storybook/client-logger';\nimport { types } from './types';\nexport { Channel };\nexport var AddonStore = function AddonStore() {\n  var _this = this;\n\n  _classCallCheck(this, AddonStore);\n\n  this.loaders = {};\n  this.elements = {};\n  this.config = {};\n  this.channel = void 0;\n  this.serverChannel = void 0;\n  this.promise = void 0;\n  this.resolve = void 0;\n\n  this.getChannel = function () {\n    // this.channel should get overwritten by setChannel. If it wasn't called (e.g. in non-browser environment), throw.\n    if (!_this.channel) {\n      throw new Error('Accessing non-existent addons channel, see https://storybook.js.org/basics/faq/#why-is-there-no-addons-channel');\n    }\n\n    return _this.channel;\n  };\n\n  this.getServerChannel = function () {\n    if (!_this.serverChannel) {\n      throw new Error('Accessing non-existent serverChannel');\n    }\n\n    return _this.serverChannel;\n  };\n\n  this.ready = function () {\n    return _this.promise;\n  };\n\n  this.hasChannel = function () {\n    return !!_this.channel;\n  };\n\n  this.hasServerChannel = function () {\n    return !!_this.serverChannel;\n  };\n\n  this.setChannel = function (channel) {\n    _this.channel = channel;\n\n    _this.resolve();\n  };\n\n  this.setServerChannel = function (channel) {\n    _this.serverChannel = channel;\n  };\n\n  this.getElements = function (type) {\n    if (!_this.elements[type]) {\n      _this.elements[type] = {};\n    }\n\n    return _this.elements[type];\n  };\n\n  this.addPanel = function (name, options) {\n    _this.add(name, Object.assign({\n      type: types.PANEL\n    }, options));\n  };\n\n  this.add = function (name, addon) {\n    var type = addon.type;\n\n    var collection = _this.getElements(type);\n\n    collection[name] = Object.assign({\n      id: name\n    }, addon);\n  };\n\n  this.setConfig = function (value) {\n    Object.assign(_this.config, value);\n  };\n\n  this.getConfig = function () {\n    return _this.config;\n  };\n\n  this.register = function (name, registerCallback) {\n    if (_this.loaders[name]) {\n      logger.warn(\"\".concat(name, \" was loaded twice, this could have bad side-effects\"));\n    }\n\n    _this.loaders[name] = registerCallback;\n  };\n\n  this.loadAddons = function (api) {\n    Object.values(_this.loaders).forEach(function (value) {\n      return value(api);\n    });\n  };\n\n  this.promise = new Promise(function (res) {\n    _this.resolve = function () {\n      return res(_this.getChannel());\n    };\n  });\n}; // Enforce addons store to be a singleton\n\nvar KEY = '__STORYBOOK_ADDONS';\n\nfunction getAddonsStore() {\n  if (!global[KEY]) {\n    global[KEY] = new AddonStore();\n  }\n\n  return global[KEY];\n} // Exporting this twice in order to to be able to import it like { addons } instead of 'addons'\n// prefer import { addons } from '@storybook/addons' over import addons from '@storybook/addons'\n//\n// See public_api.ts\n\n\nexport var addons = getAddonsStore();","map":{"version":3,"sources":["/Users/michaelnisnevich/Desktop/typescript/React_Kabzda_kak_podrobno/node_modules/@storybook/addons/dist/esm/index.js"],"names":["_classCallCheck","instance","Constructor","TypeError","global","Channel","logger","types","AddonStore","_this","loaders","elements","config","channel","serverChannel","promise","resolve","getChannel","Error","getServerChannel","ready","hasChannel","hasServerChannel","setChannel","setServerChannel","getElements","type","addPanel","name","options","add","Object","assign","PANEL","addon","collection","id","setConfig","value","getConfig","register","registerCallback","warn","concat","loadAddons","api","values","forEach","Promise","res","KEY","getAddonsStore","addons"],"mappings":"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","sourcesContent":["import \"core-js/modules/es.object.assign.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.object.values.js\";\nimport \"core-js/modules/es.promise.js\";\nimport \"core-js/modules/es.object.to-string.js\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nimport global from 'global';\nimport { Channel } from '@storybook/channels';\nimport { logger } from '@storybook/client-logger';\nimport { types } from './types';\nexport { Channel };\nexport var AddonStore = function AddonStore() {\n  var _this = this;\n\n  _classCallCheck(this, AddonStore);\n\n  this.loaders = {};\n  this.elements = {};\n  this.config = {};\n  this.channel = void 0;\n  this.serverChannel = void 0;\n  this.promise = void 0;\n  this.resolve = void 0;\n\n  this.getChannel = function () {\n    // this.channel should get overwritten by setChannel. If it wasn't called (e.g. in non-browser environment), throw.\n    if (!_this.channel) {\n      throw new Error('Accessing non-existent addons channel, see https://storybook.js.org/basics/faq/#why-is-there-no-addons-channel');\n    }\n\n    return _this.channel;\n  };\n\n  this.getServerChannel = function () {\n    if (!_this.serverChannel) {\n      throw new Error('Accessing non-existent serverChannel');\n    }\n\n    return _this.serverChannel;\n  };\n\n  this.ready = function () {\n    return _this.promise;\n  };\n\n  this.hasChannel = function () {\n    return !!_this.channel;\n  };\n\n  this.hasServerChannel = function () {\n    return !!_this.serverChannel;\n  };\n\n  this.setChannel = function (channel) {\n    _this.channel = channel;\n\n    _this.resolve();\n  };\n\n  this.setServerChannel = function (channel) {\n    _this.serverChannel = channel;\n  };\n\n  this.getElements = function (type) {\n    if (!_this.elements[type]) {\n      _this.elements[type] = {};\n    }\n\n    return _this.elements[type];\n  };\n\n  this.addPanel = function (name, options) {\n    _this.add(name, Object.assign({\n      type: types.PANEL\n    }, options));\n  };\n\n  this.add = function (name, addon) {\n    var type = addon.type;\n\n    var collection = _this.getElements(type);\n\n    collection[name] = Object.assign({\n      id: name\n    }, addon);\n  };\n\n  this.setConfig = function (value) {\n    Object.assign(_this.config, value);\n  };\n\n  this.getConfig = function () {\n    return _this.config;\n  };\n\n  this.register = function (name, registerCallback) {\n    if (_this.loaders[name]) {\n      logger.warn(\"\".concat(name, \" was loaded twice, this could have bad side-effects\"));\n    }\n\n    _this.loaders[name] = registerCallback;\n  };\n\n  this.loadAddons = function (api) {\n    Object.values(_this.loaders).forEach(function (value) {\n      return value(api);\n    });\n  };\n\n  this.promise = new Promise(function (res) {\n    _this.resolve = function () {\n      return res(_this.getChannel());\n    };\n  });\n}; // Enforce addons store to be a singleton\n\nvar KEY = '__STORYBOOK_ADDONS';\n\nfunction getAddonsStore() {\n  if (!global[KEY]) {\n    global[KEY] = new AddonStore();\n  }\n\n  return global[KEY];\n} // Exporting this twice in order to to be able to import it like { addons } instead of 'addons'\n// prefer import { addons } from '@storybook/addons' over import addons from '@storybook/addons'\n//\n// See public_api.ts\n\n\nexport var addons = getAddonsStore();"]},"metadata":{},"sourceType":"module"}